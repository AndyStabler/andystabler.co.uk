---
title: Proxies in ECMAScript
date: 2018-03-19
---

### What are they?

Proxies were introduced in ECMAScript 6 and give developers the opportunity to create objects that behave more
like those built-in to the JavaScript engine.

They intercept low-level method calls, such as those that get/set a property, allowing the developer to customise
the call.

#### Some layman definitions:

* Proxy: An object that intercepts method calls
* Target: The object the proxy is intercepting calls from
* Handler: The proxy looks in this object for any trap methods that you may have provided
* Trap: A function you add to a handler object that tells the proxy what to do when a specific method on the target
is called


### Example

I find the best way to explain/learn a new concept is with an example, so here's a simple one that adds logging
for getting/setting a property.

<% code_tag "js" do %>
  // this is going to be our target
  let friend = {
    name: "Luna Lovegood",
    house: "Ravenclaw",
    patronus: "Hare",
  };

  // the handler for the proxy. This contains trap methods.
  let handler = {
    // this is a trap method
    // this method will be called when we read a property on the proxy
    get(trapTarget, key, receiver) {
      console.log(`Getting property "${key}"`);
      // The Reflect object provides us with the default implementation
      // There's a Reflect method for all proxy trap methods
      return Reflect.get(trapTarget, key, receiver);
    },
    // this is another trap method
    // this method will be called when we set a property on the proxy
    set(trapTarget, key, value, receiver) {
      console.log(`Setting property "${key}"`);
      // The Reflect object provides us with the default implementation
      // There's a Reflect method for all proxy trap methods
      return Reflect.set(trapTarget, key, value, receiver);
    }
  };

  // creating the proxyâ€“ we pass in the friend (target) and the handler
  let friendProxy = new Proxy(friend, handler);

  friendProxy.name;
  // Getting property "name"
  // 'Luna Lovegood'

  friendProxy.hobby = "Painting";
  // Setting property "hobby"
  // 'Painting'
<% end %>

What I find interesting about proxies however, is that they can be used to add validation to objects.

### Using proxies for validation

#### Checking argument types

Since we can intercept the `apply` function, we can add some validation to make sure that, when a function is called,
the arguments passed into it are what we'd expect.

<% code_tag "js" do %>
  function speak(message) {
    console.log(`Raising your head, you declare to the room "${message}"`);
  }

  let speakProxy = new Proxy(speak, {
    apply(trapTarget, thisArg, argumentsList) {
      if (argumentsList.length != 1) {
        throw new Error("Please say one thing at a time");
      }
      if (typeof argumentsList[0] !== "string") {
        throw new TypeError("Please use your words");
      }

      Reflect.apply(trapTarget, thisArg, argumentsList);
    }
  });

  speakProxy("Wingardium Leviosa"); // Raising your head, you declare to the room "Wingardium Leviosa"
  speakProxy("Wingardium Leviosa", "Accio Firebolt!"); // Error: Please say one thing at a time
  speakProxy(42); // TypeError: Please use your words
<% end %>

#### Checking typos on property names


